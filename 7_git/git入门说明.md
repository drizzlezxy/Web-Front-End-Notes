## 本地仓库&远端仓库

### 1. 建立本地仓库
- 新建本地仓库
	
	```
	git init	
	```
	此时当前文件夹就是一个新的仓库。  
	该目录下会多出一个被隐藏的.git文件夹，里面的文件是用来跟踪管理版本库的，一般情况下不建议手动修改。  

- 从远端仓库检出
	
	```
	git clone [远端仓库地址]
	```
	该命令执行成功后，远端仓库会被检出到本地。

### 2. 本地仓库  
本地仓库我们可以理解它有三个区域：工作区，暂存区，版本库。后两者不可见，存在于被隐藏的文件夹.git中。  
![git工作流](img/git_local.png)
- 工作区  
	可见文件的区域，我们对文件的操作都是针对工作区的。  

	当对工作区的文件进行变更，这时候，这些变更没有被提交（暂存区或版本库），用`git status`命令可以看到以下状态，工作区是脏的。  
	![工作区](img/workspace.png)  

- 暂存区  
	顾名思义，将变更提交的暂存区，提交到版本库的过渡。

	```
	git add [file]
	```
	`add`命令可以将工作区的变更添加到暂存区。（`git add .`可以将所有变更添加到暂存区）
	此时再用`git status`命令可以看到以下状态。  
	![暂存区](img/stage.png)  

- 版本库  
	对已经提交的变更进行版本管理。  
	![版本库](img/banben.png)   
	每个版本节点中存有当前提交的一些文件信息，如果文件后续变更后，还需要之前的文件信息，则可以从版本库中检出之前的文件信息。  
	`commit`命令可以将暂存区的变更保存至版本库，形成一个新的版本节点。

	```
	git commit -m '[变更的描述]'
	```
	同样的，用`git status`查看状态，工作区是干净的，没有需要提交的内容。
	![版本库](img/commit.png)
 
- HEAD  
	到这里我们可以看到，版本库里面有许多的版本节点，那么我们的工作区到底显示的是哪个版本的文件，是在对哪个版本下的文件进行变更呢？  
	HEAD就起到这样一个作用，类似于当前活跃版本节点的指针：HEAD指向的位置，就是我们当前工作区所在的版本节点，包括后面会提到的分支切换，其实也是HEAD指针指向的版本节点的切换。  
	比如，我们用reset指令将工作区的内容切换到之前的版本（描述为'UrlUtil modified'）：    
	![HEAD指针](img/HEAD.png)  
	可以看到提示**HEAD is now at c0f2e25 UrlUtil modified**。

### 3. 远端仓库
远端仓库是这样的一个角色，所有人都可以从远端仓库托管的文件克隆一份到自己的电脑上，并且各自把各自的提交推送到远端仓库里，也从远端仓库中拉取别人的提交。
![远端版本库](img/remote.png)

对远端仓库我们有两个基本的操作，这两个操作都是在本地版本库和远端版本库间的操作。

- 推送本地版本至远端  
	![比远端超前一个版本](img/ahead.png)  
	可见上图中，本地版本库有一个新的提交版本没有推送到远端，这时候远端没有我们本地最新版本的信息，需要执行以下命令将本地的最新版本信息推送到远端。

	```
	git push
	```
	执行之后，就把本地的最新版本推送到远端了。

- 将远端版本拉到本地仓库  
	类似的，如果别人对把他们的变更提交到远端，这时候我们本地版本库就比远端落后几个版本，我们可以通过`pull`命令将远端的版本拉到本地。

	```
	git pull
	```

#### 文件冲突
如果我们想要把本地的变更push到远端的时候，远端版本库被别人提交过了，这时候就会出现提交失败的情况，就像下图的情况。  
![需要merge的情况](img/needMerge.png)  
这时候我们需要3步：  

1. 将远端最新的版本拉到本地

	```
	git pull
	```
	这时候，如果远端的变更跟本地变更没有冲突，则会快速合并，即可以跳过下一步，直接进行第3步。  
	若有冲突，则会提示以下信息：  
	![快速合并失败](img/autoMergeFailed.png)  
2. 合并远端仓库和本地的变更  
	首先需要手动解决冲突的文件。`git status`查看状态，打开`both modified`路径下的文件，会出现如下提示信息：  
	![冲突文件](img/conflicts.png)  
	 手动将冲突的文件修改后，再执行以下步骤提交。

	```
	git add .
	git commit -m '[提交的描述（合并远端冲突）]'
	```
3. 提交本地变更

	```
	git push
	```
	到执行了这条`push`之后，我们才算把之前想要提交到远端的代码push到了远端仓库。
	
	
## 分支&分支管理
分支可以帮助我们更好地**互不干扰地**进行协同开发。
![分支](img/branch.png)  
当我们新建一个git仓库时，默认是在master分支上。

- 根据当前版本号上的内容 新建一个分支  

	```
	# 新建一个分支，并且切换到该分支上(HEAD指向新的分支)
	git checkout -b [分支名]

	# 新建一个分支，不切换
	git branch [分支名]
	```
- 分支切换
	
	```
	git checkout [分支名]
	```

- 分支合并

	```
	# 将其他分支合并到当前分支
	merge [其他分支名]
	```

	merge过程中也可能会遇到有冲突的情况，需要我们手动解决冲突，类似于上面提到的**文件冲突**。	

### Git Flow分支管理模型  

- **master**  
	随时可发布的代码，这里的代码都是测试完成的，已上线的；在master打tag，所有上线了的版本的tag都打在这里；
- **develop**  
	永远是功能最新最全的分支，所有开发完成的功能都合并到该分支上；这个分支上的代码不一定都是测试完成的，大部分都是待测试的；
- hotfix  
	修复线上代码的 bug，它派生于master分支，修改完成并且测试完成后，合并到master和develop上；
- feature  
	某个功能点正在开发阶段的代码，它派生于develop分支，开发完成后，合并到develop上等待测试；
- release  
	要上线的功能，它派生于develop分支，测试完成可以上线后，分别合并到master和develop上；派生出某个release后，develop分支可以接着开发别的功能而不影响到上个release；  
![Git Flow分支管理模型](img/branchTree.png)